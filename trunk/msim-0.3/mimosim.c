/* Copyright (c) 2004 Miguel Bazdresch

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Please see the file LICENSE for more details. */

/* $Id: mimosim.c,v 1.8 2004/08/16 17:25:55 miguel Exp $ */

/* MIMO Simulator */

/*
 * If you have a license to run NR code, and we wish to use it,
 * then define the following variable. Otherwise undefine it.
 *
 */
/* #define NR_LICENSED */

/* debug=1 causes debug code to be included */
/* #define debug 1 */
#define debug 0
/* standard library includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

/* function prototypes */
#include "mimosim.h"

/* Declaration and default values of control variables */
/* These variables are global because most functions */
/* need to read them. */
/* ---- Variables that are set through mimosim.ini file ---- */
/* ---- default values are set here too                 ---- */
unsigned int cDebug = 0;
int experimental = 0;
int exp_vb_ordering = 0;
int exp_vb_cancellation = 0;
unsigned int iReceiverType = 0;
int CycleVblastTypes = 0;
double fConstellationSymbolEnergy = 1.0;
int L = 10;
int CycleL=0;
unsigned int Lt = 4;
unsigned int cConstellationType = 0;
unsigned int cSourceType = 0;
long iSourceSeed = 0;
long iNoiseSeed = 0;
long iHSeed = 0;
unsigned int cTransmitAntennas = 8;
unsigned int cReceiveAntennas = 12;
double fNoisePower = -2.0;
double NStep = 1;
int NIterations = 1;
int LIterations = 1;
int LStep = 1;
int DoLLL = 1;
int CycleLLL=0;
int ScreenFeedback = 1;
int IndexComFile = 1;
unsigned int cMatrixHComponentGen = 0;
unsigned int cMethodChannelEstimation = 0;
unsigned int cChannelCode = 0;
unsigned int cTypeTrainingSeq = 0;
unsigned int iNumberOfErrors = 100;
unsigned int iRunFrames = 0;
unsigned int iResume = 0;
/* ---- Variables that hold the data generated by the program ---- */
unsigned int N, M, N2, M2;
double fCodeRate; /* determined by the type of code */
unsigned int iBitsPerSymbol; /* determined by the constellation type */
unsigned int iNumberInfoBitsFrame;
unsigned int iNumberTrainBitsFrame;
unsigned int iNumberCodedBitsFrame;
unsigned int iFrameCounter; /* Counts how many frames have been simulated */
unsigned int *pSourceBits, *pCodedBits, **pTransmitMatrix;
unsigned int *pEstimatedBits;
double **pModulated;
unsigned int *pTrainSequence;
double **pReceived, **noisematrix, *testvector;
double ***storedpinvs;
double BER, BLER, SER;
double e1, e3;
/* variance of elements of noise and H */
double Nvar, Hvar;
/* variables to count errors */
unsigned int biterrors, blockerrors, symerrors;
/* time variable for random seeds */
time_t t;
/* variables to calculate run time */
time_t timex;
long initial_time;
long suspend_time;
long end_time;
long run_time;
/* variables to estimate signal power */
double EstSentPwr, EstRxPwr, EstNoisePwr;
/* variable to detect keypresses */
int charread = 0;
/* --------------------------------- */
/* variables used by VBLAST receiver */
/* --------------------------------- */
/* decoding order stored in k */
int *k;
/* a stores the symbols estimated by BLAST; it's a complex vector */
double *a;
/* wg stores the selected rows of G, step 9d */
double *wg;
/* y stores the unquantized symbols estimated by BLAST; it's a complex number */
double yReal, yImag;
/* r is the ri vector in vblast */
double *r;
/* H needs to be stored because it is altered during VBLAST (columns are nulled) */
double **pHWork;
/* Reduced form of pseudoinverse */
double **pT, **pZ;
/* other matrices */
double **pTT, **pTTinv;
double **Q, **R, *b, *xls, **Q1, **R1, **tempM;
double *tempV;
unsigned int *permut, *rc, *origor;
/* ------------------------------------- */
/* Variables used both for ML and VBLAST */
/* ------------------------------------- */
/* These variables have different sizes depending on ML or VBLAST */
/* channel matrix */
double **pH; /* ML: 2Mx2N  VBLAST: 2Nx2M */
/* HTemp stores temporarilly H because svdcmp changes it */
double **pHTemp;
/* QAM threshold levels (used for slicing) */
double t1, t2, t3;
/* used to calculate the pinv */
double **pV, *pW;
/* used by svdcmp */
double *rv1;
/* used by the inverse in NR_LICENSED algorithm */
#ifdef NR_LICENSED
double *ludcmp_vv;
int *ludcmp_indx;
#endif
/* -------------------- */
/* Variables used by ML */
/* -------------------- */
double **G; /* channel matrix in form needed for ML. lattice generator matrix. */
double **G_t;
double **G_i; /* the pinv of G */
double **G_copy; /* needed by pinv and thinqr */
double **bstar, **mu, *B, *bt; /* used in LLL algorithm */
double **Q_t, **G3_t, **G3_t_org; /* used by thinqr algorithm */
double **G3, **G3_org;
double **H3, *x3, *xest; /* used in decode algorithm */
double *col_inv; /* used by matrix inverse */
/* used in decode algorithm: */
double *dist; /* 1xM2 */
double **e; /* M2xM2 */
double *u; /* 1xM2 */
double *step; /* 1xM2 */
double *u3, *u3_; /* 1xM2 */
double *foo; /* 1xN2, aux variable */
double *translate; /* 1xN2, vector used to translate receive point */
/* variables needed for random number generation */
gsl_rng * source_rng, * noise_rng, * hchannel_rng, * hrx_rng;
const gsl_rng_type * type_rng;
int    firstwd;
/* ---------------------------- */
/* Variables used in vb-reduced */
/* ---------------------------- */
double *g, *tempv, *t_est;
/* ------------------------------------ */
/* Variables used to measure complexity */
/* ------------------------------------ */
/* xx controls the complexity calculations */
#define xx if(1)
/* #define xx if(0) */
/* rows */
#define form 1
#define psin 2
#define vrec 3
#define mrec 4
#define deco 5
#define LLL  6
#define thqr 7
#define qrup 8
#define svd 9
#define _rows 9
/* columns */
#define add 1
#define add_mm 2
#define mul 3
#define mul_mm 4
#define div 5
#define srt 6
#define mem 7
#define mem_mm 8
#define mem_mc 9
#define mem_mz 10
#define _cols 10 
unsigned long long x[_rows+1][_cols+1];
#define xt x[totl]
#define xp x[psin]
#define xv x[vrec]
#define xm x[mrec]
#define xd x[deco]
#define xl x[LLL]
#define xh x[thqr]
#define xq x[qrup]
#define xs x[svd]
#define xf x[form]
#define xg x[gtotal]

/* ---- Output files ---- */
char filemod;
FILE *outfile;
char fout[20];
FILE *svdfile;
char fsvd[20];
FILE *powerfile;
char fpower[20];
FILE *hfile;
char fh[20];
FILE *errfile;
char ferr[20];
FILE *susfile;
FILE *comfile;
char fcom[20];
FILE *noisefile;
FILE *datafile;

/* include functions in other files */
#include "complex.c"
#include "random.c"
#include "debug.c"
#include "matrix.c"
#include "nr_functions.c"
#include "support.c"
#include "support_ml.c"
#include "memoryalloc.c"
#include "parser.c"
#include "source.c"
#include "coder.c"
#include "modulator.c"
#include "channel.c"
#include "chestimator.c"
#include "vblastreceiver.c"
#include "mlreceiver.c"
#include "vb-reduced.c"
#include "vb-wubben.c"
#ifdef NR_LICENSED
#include "nr_licensed.c"
#endif

int main (void) {
    
    /* function prototypes */
    int parser( void );
    int source( void );
    int coder( void );
    int modulator( void );
    int channel( void );
    int chestimator( void );
    int vblastreceiver( void );
    int mlreceiver( void );
    int allocate_mem( int );

    int    runresult, i, j;
    int    conditionV, conditionLLL, conditionL, conditionR, conditionN;
    int    L_times, L_initial, L_max;
    double N_times, N_initial, R_initial;

    srand( time(0) );
    
    /* ---------- */
    /* Run Parser */
    /* ---------- */
    printf( "Running Parser.... \n" );
    runresult = parser();
    if( !runresult ) {
	printf( "Parser completed successfully\n" );
    }
    else {
	printf( "Parser returned error number: %u\n", runresult );
	return 1;
    }
    
    if( N < M ) {
	printf( "Error: the number of Tx antennas must be less than\n" );
	printf( "       or equal to the number of Rx antennas.\n" );
	printf( "       N = %d; M = %d\n", N, M );
	return 1;
    }
    
    /* open noise and data files if cDebug contains 512 */
    if( debug && ((cDebug & 512) == 512) ) {
	noisefile = fopen( "noise.out", "r" );
	if( noisefile == NULL ) {
	    printf( "Error opening noise file!\n" );
	    fclose( noisefile );
	    return 1;
	}
	datafile = fopen( "data.out", "r" );
	if( datafile == NULL ) {
	    printf( "Error opening data file!\n" );
	    fclose( datafile );
	    return 1;
	}
    }
    /* ----------------- *
     * open output files *
     * ----------------- */
    filemod = 'w';
    sprintf( fout,"results/M%dN%d.out",cTransmitAntennas,cReceiveAntennas );
    sprintf( fpower,"results/M%dN%d.power",cTransmitAntennas,cReceiveAntennas );
    sprintf( fsvd,"results/M%dN%d.svd",cTransmitAntennas,cReceiveAntennas );
    sprintf( fh,"results/M%dN%d.mh",cTransmitAntennas,cReceiveAntennas );
    sprintf( ferr,"results/M%dN%d.err",cTransmitAntennas,cReceiveAntennas );
    sprintf( fcom,"results/M%dN%d.com",cTransmitAntennas,cReceiveAntennas );
    
    outfile = fopen( fout, &filemod );
    if( outfile  == NULL ) {
	printf( "Error opening file mimosim.out!\n" );
	fclose( outfile );
	return 1;
    }
    powerfile = fopen( fpower, &filemod ); 
    if( powerfile == NULL ) {
	printf( "Error opening file mimosim-power.out!\n" );
	fclose( powerfile );
	return 1;
    }
    svdfile = fopen( fsvd, &filemod );
    if( svdfile == NULL ) {
	printf( "Error opening file mimosim-svd.out!\n" );
	fclose( svdfile );
	return 1;
    }
    hfile = fopen( fh, &filemod );
    if( hfile == NULL ) {
	printf( "Error opening file mimosim-h.out!\n" );
	fclose( hfile );
	return 1;
    }
    errfile = fopen( ferr, "w" );
    if( errfile == NULL ) { /* errfile always overwritten */
	printf( "Error opening file mimosim-err.out!\n" );
	fclose( errfile );
	return 1;
    }
    comfile = fopen( fcom, &filemod );
    if( comfile == NULL ) {
	printf( "Error opening file mimosim-com.out!\n" );
	fclose( comfile );
	return 1;
    }
    /* --------------------------------------------------- *
     * Calculate quantities needed in subsequent functions *
     * --------------------------------------------------- */
    N = cReceiveAntennas;
    M = cTransmitAntennas;
    N2 = 2*N;
    M2 = 2*M;

    /* Determine code rate */
    switch( cChannelCode ) {
	case 0: /* no coding */
	    fCodeRate = 1.0;
	    break;
	default:
	    printf( "cChannelCode = %d not implemented, exiting\n", \
		     cChannelCode );
	    return 1;
    }
    /* Determine bits per symbol and constellation energy*/
    switch( cConstellationType ) {
	case 0: /* 16-QAM */
	    iBitsPerSymbol = 4;
	    e1 = fConstellationSymbolEnergy;
	    e3 = 3.0*e1;
	    /* thresholds used for slicing */
	    t3 = (e3+e1)/2;
	    t1 = -t3;
	    t2 = 0.0;
	    break;
	case 1: /* 4-QAM */
	    iBitsPerSymbol = 2;
	    e1 = fConstellationSymbolEnergy;
	    break;
	default:
	    printf( "cConstellationType = %d not implemented, exiting\n", \
		     cConstellationType );
	    return 1;
    }
    /* -------------------------- *
     * Allocate all needed memory *
     * -------------------------- */
    L_max = L + LStep*(LIterations - 1);
    iNumberCodedBitsFrame = (L_max*iBitsPerSymbol*M);
    iNumberInfoBitsFrame = iNumberCodedBitsFrame/(int)fCodeRate;
    iNumberTrainBitsFrame = Lt*iBitsPerSymbol*M;
	    
    printf( "Allocating memory... \n" );
    runresult = allocate_mem( L_max );
    if ( !runresult ) {
	printf( "Memory allocated successfully\n" );
    }
    else {
	printf( "Memory allocation returned error number: %u\n", runresult );
	return 1;
    }
    
    /* initialize rngs */
    initialize_rng();
    
    if ( iSourceSeed == 0.0 )
	iSourceSeed = (unsigned long int) time(&t);
    gsl_rng_set(source_rng, iSourceSeed);
    
    if ( iNoiseSeed == 0.0 )
	iNoiseSeed = gsl_rng_get(source_rng);
    gsl_rng_set(noise_rng, iNoiseSeed);
    
    if ( iHSeed == 0.0 )
	iHSeed = gsl_rng_get(source_rng);
    gsl_rng_set(hchannel_rng, iHSeed);
    gsl_rng_set(hrx_rng, iHSeed);
    
    /* save value of some variables */
    N_initial = fNoisePower;
    L_initial = L;
    R_initial = iReceiverType;
    
    Hvar = 1.0 / sqrt( 2.0 ); /* power of components of H */
    
    /* set up LLL loop */

    conditionLLL = 0;
    
    if( CycleLLL && (iReceiverType == 0) ) {
	DoLLL = 1;
	conditionLLL = 1;
    }

    do { /* LLL loop */
	
	/* set up L loop */
	conditionL = 0;
	if( CycleL )
	    conditionL = 1;

	L_times = 1;
	L = L_initial;
	
	do { /* L loop */

	    /* set up receiver type loop */
	    conditionR = 0;
	    if( (CycleVblastTypes == 1) && \
		(iReceiverType >= 1) && (iReceiverType <= 6) ) {
		conditionR = 1;
		iReceiverType = 1;
	    }
	    
	    iNumberCodedBitsFrame = L*iBitsPerSymbol*M;
	    iNumberInfoBitsFrame = iNumberCodedBitsFrame/(int)fCodeRate;
	    iNumberTrainBitsFrame = Lt*iBitsPerSymbol*M;
	    
	    do { /* VBlast type loop */
		
		/* set up noise power loop */
		firstwd = 1;
		N_times = 1;
		conditionN = 1;
		fNoisePower = N_initial;
		
		do { /* noise power loop */
		    
		    /* re-initialize rngs */
		    gsl_rng_set( source_rng, iSourceSeed );
		    gsl_rng_set( noise_rng, iNoiseSeed );
		    gsl_rng_set( hchannel_rng, iHSeed );
		    gsl_rng_set( hrx_rng, iHSeed );
		    
		    if( fNoisePower != -2.0 ) {
			double snri, aux;
			
			snri = pow( 10.0, fNoisePower/10 );
			aux = (double)M / snri;
			Nvar = sqrt( aux/2.0 );
			
			fprintf( errfile, "Nominal SNR = %1.10f\n", fNoisePower );
			fprintf( powerfile, "Nominal SNR = %1.10f\n", fNoisePower );
			fprintf( errfile, "Square root of noise power \
				divided by 2 = %1.10f\n", Nvar );
			fprintf( powerfile, "Sqrt of noise power divided \
				by 2 = %1.10f\n\n", Nvar );
		    }
		    else {
			Nvar = 0.0;
			fprintf( errfile, "\n%%%% No noise in channel.\n\n" );
			fprintf( powerfile, "\n%%%% No noise in channel.\n\n" );
		    }
		    
		    /* Set frame counter to zero and other variables */
		    iFrameCounter = 0;
		    conditionV = 1;
		    biterrors = 0;
		    blockerrors = 0;
		    symerrors = 0;
		    EstNoisePwr = 0.0;
		    EstSentPwr= 0.0;
		    EstRxPwr = 0.0;
		    
		    /* reset comp counters */
		    for( i=1; i<=_rows; i++ )
			for ( j=1; j<=_cols; j++ )
			    x[i][j] = 0;
		    
		    /* ------------------------------------------------------- *
		     * Main Loop - this loop processes one whole frame, and is *
		     *             repeated until number of errors > threshold *
		     * ------------------------------------------------------- */
		    
		    printf( "Running main loop \n" );
		    printf( "ReceiverType set to %d\n", iReceiverType );

		    printf("M = %d\n",M);
		    printf("N = %d\n",N);
		    printf("Receiver = %d\n",iReceiverType);
		    printf("%2.1fdB, NVar = %1.5f\n", fNoisePower, Nvar);
			
		    while( conditionV ) {

			/* Run Source */
			runresult = source();
			if( runresult ) {
			    printf( "Source returned error number: %u\n", \
				    runresult );
			    return 1;
			}
			
			/* Run Coder */
			runresult = coder();
			if( runresult ) {
			    printf( "Coder returned error number: %u\n", \
				    runresult );
			    return 1;
			}
			
			/* Run Modulator */
			runresult = modulator();
			if( runresult ) {
			    printf( "Modulator returned error number: %u\n", \
				    runresult );
			    return 1;
			}
			
			/* Run Channel */
			runresult = channel();
			if( runresult ) {
			    printf( "Channel returned error number: %u\n", \
				    runresult );
			    return 1;
			}

			/* Run Channel Estimator */
			runresult = chestimator();
			if( runresult ) {
			    printf( "Channel estimator returned error number: \
				    %u\n", runresult );
			    return 1;
			}
			
			/* run Receiver */
			if( iReceiverType == 1 ||
				iReceiverType == 2 ||
				iReceiverType == 3 ||
				iReceiverType == 4 ) {
			    /* VBLAST receiver */
			    runresult = vblastreceiver();
			}
			else if( iReceiverType == 0 )
			    /* ML receiver */
			    runresult = mlreceiver();
			else if( iReceiverType == 5 )
			    /* Reduced VB receiver */
			    runresult = vb_reduced();
			else if( iReceiverType == 6 )
			    runresult = vb_wubben();
			
			if( runresult ) {
			    printf( "Receiver returned error number: %u\n", \
				   runresult );
			    return 1;
			}
			
			iFrameCounter++;
			/* Determine stop condition:
			 * If noise power==-2, then
			 *   simulate iNumberOfErrors frames
			 * If noise power!=-2, then
			 *   simulate until biterrors is over the threshold
			 * */
			if( (fNoisePower == -2.0) || (iNumberOfErrors == 0) ) {
			    if( iFrameCounter == iRunFrames ) {
				conditionV = 0;
			    }
			}
			else {
			    if( blockerrors >= iNumberOfErrors ) {
				conditionV = 0;
			    }
			}
		    }
		    
		    /* ------------------------------ *
		     * Calculate errors and wind down *
		     * ------------------------------ */
		    winddown();
		    
		    /* run some stuff in winddown only once */
		    if( firstwd )
			firstwd=0;
		    
		    /* condition for stopping N loop */
		    if( N_times == NIterations )
			conditionN = 0;
		    
		    if( NIterations != 1 ) {
			N_times++;
			fNoisePower += NStep;
		    }
		    
		} while( conditionN );
		
		/* condition for stopping R loop */
		if( (CycleVblastTypes == 1)
		      && (R_initial != 0) )
		    iReceiverType++;

		if( iReceiverType == 7 ) {
		    conditionR = 0;
		    iReceiverType = R_initial;
		}
		
	    } while( conditionR );
	    
	    /* condition for stopping L loop */
	    if( L_times == LIterations )
		conditionL = 0;

	    if( CycleL ) {
		L_times++;
		L = L + LStep;
	    }
	    
	} while( conditionL );
	
	/* condition for stopping LLL loop */
        if( DoLLL == 0 )
	    conditionLLL = 0;
	    	
	if( DoLLL == 1 )
	    DoLLL = 0;
	
    } while( conditionLLL );
    
    /* ----------- *
     * close files *
     * ----------- */
    fclose( outfile );
    fclose( svdfile );
    fclose( powerfile );
    fclose( hfile );
    fclose( errfile );
    fclose( comfile );
    printf( "End of MIMO simulation.\n" );

    return 0;
}
